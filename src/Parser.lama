-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun consBinop(l, op, r) {
  Binop (op, l, r)
}

-- Primary expression
var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")"))),
    exp = memo $ eta expr ({
        [Left, {
          [s("!!"), consBinop]
        }],
        [Left, {
          [s("&&"), consBinop]
        }],
        [Nona, {
          [s("<"),  consBinop],
          [s(">"),  consBinop],
          [s("<="), consBinop],
          [s(">="), consBinop],
          [s("=="), consBinop],
          [s("!="), consBinop]
        }],
        [Left, {
          [s("+"),  consBinop],
          [s("-"),  consBinop]
        }],
        [Left, {
          [s("*"),  consBinop],
          [s("/"),  consBinop],
          [s("%"),  consBinop]
        }]}, primary);



var stmt = memo $ eta syntax (
        l=oneStmt s[";"] r=stmt {Seq (l, r)} |
        oneStmt
      ),
      oneStmt = memo $ eta syntax (
        l=lident s[":="] r=exp                                    {Assn (l, r)}       |
        kSkip                                                     {Skip}              |
        kRead  x=inbr[s("("), lident, s(")")]                     {Read (x)}          |
        kWrite x=inbr[s("("), exp,    s(")")]                     {Write (x)}         |
        kIf e=exp kThen t=stmt                  kFi               {If (e, t, Skip)}   |
        kIf e=exp kThen t=stmt kElse f=stmt     kFi               {If (e, t, f)}      |
        kIf e=exp kThen t=stmt       f=elifStmt kFi               {If (e, t, f)}      |
        kWhile e=exp kDo body=stmt kOd                            {While (e, body)}   |
        kDo body=stmt kWhile e=exp kOd                            {DoWhile (body, e)} |
        kFor b=stmt s[","] e=exp s[","] st=stmt kDo body=stmt kOd {Seq (b, While (e, Seq (body, st)))}
      ),
      elifStmt = memo $ eta syntax (
        kElif e=exp kThen t=stmt kElse f=stmt {If (e, t, f)} |
        kElif e=exp kThen t=stmt f=elifStmt   {If (e, t, f)}
      );
   

-- Public top-level parser
public parse = stmt;
